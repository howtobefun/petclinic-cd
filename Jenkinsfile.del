// vim: syntax=groovy
pipeline {
    agent any
    parameters {
        string(name: 'BUILD_NUMBER_TO_DELETE', defaultValue: '', description: 'Build number of the deployment to delete (leave empty for auto-cleanup)')
    }
    stages {
        stage('Determine Builds to Delete') {
            when {
                expression { params.BUILD_NUMBER_TO_DELETE == '' }
            }
            steps {
                script {
                    // Find deployments older than 1 hour
                    def buildsToDelete = []
                    def cutoffTime = new Date().time - (1 * 60 * 60 * 1000) // 1 hour ago
                    def project = Jenkins.instance.getItemByFullName('petclinic-cd') // Replace with your multibranch project name
                    if (!project) {
                        error "Project 'petclinic-cd' not found. Please verify the job name."
                    }
                    // Iterate over jobs (branches) in the multibranch project
                    project.getAllJobs().each { job ->
                        job.builds.each { build ->
                            if (build.timeInMillis < cutoffTime && build.result != hudson.model.Result.FAILURE) {
                                def metadataFile = "${build.getRootDir()}/archive/deployment-${build.number}.txt"
                                if (new File(metadataFile).exists()) {
                                    buildsToDelete << build.number
                                }
                            }
                        }
                    }
                    env.BUILDS_TO_DELETE = buildsToDelete.join(',')
                    if (buildsToDelete.isEmpty()) {
                        echo "No deployments older than 1 hour found."
                        currentBuild.result = 'SUCCESS'
                        return
                    }
                    echo "Found deployments to delete: ${env.BUILDS_TO_DELETE}"
                }
            }
        }
        stage('Delete Specified Deployment') {
            when {
                expression { params.BUILD_NUMBER_TO_DELETE != '' }
            }
            steps {
                script {
                    try {
                        // Use CopyArtifact plugin with specific build selector
                        copyArtifacts(
                            projectName: 'petclinic-cd', // Replace with your CD job name
                            selector: [$class: 'SpecificBuildSelector', buildNumber: "${params.BUILD_NUMBER_TO_DELETE}"],
                            filter: "deployment-${params.BUILD_NUMBER_TO_DELETE}.txt",
                            target: '',
                            optional: true // Allow step to continue if artifacts are missing
                        )
                        def metadataFile = "deployment-${params.BUILD_NUMBER_TO_DELETE}.txt"
                        if (!fileExists(metadataFile)) {
                            error "Metadata file ${metadataFile} not found for build ${params.BUILD_NUMBER_TO_DELETE}"
                        }
                        def metadata = readFile metadataFile
                        metadata.eachLine { line ->
                            def parts = line.split('=', 2) // Handle values containing '='
                            if (parts.size() == 2) {
                                env[parts[0]] = parts[1]
                            }
                        }
                        if (!env.NAMESPACE) {
                            error "Namespace not found in metadata for build ${params.BUILD_NUMBER_TO_DELETE}"
                        }
                        echo "Deleting deployment for namespace: ${env.NAMESPACE}, Build: ${params.BUILD_NUMBER_TO_DELETE}"
                        sh "kubectl delete namespace ${env.NAMESPACE} || true"
                    } catch (Exception e) {
                        echo "Error deleting specified deployment: ${e.message}"
                        throw e
                    }
                }
            }
        }
        stage('Delete Old Deployments') {
            when {
                expression { params.BUILD_NUMBER_TO_DELETE == '' && env.BUILDS_TO_DELETE }
            }
            steps {
                script {
                    def builds = env.BUILDS_TO_DELETE.split(',')
                    for (buildNum in builds) {
                        try {
                            copyArtifacts(
                                projectName: 'petclinic-cd', // Consistent job name
                                selector: [$class: 'SpecificBuildSelector', buildNumber: buildNum],
                                filter: "deployment-${buildNum}.txt",
                                target: '',
                                optional: true // Allow step to continue if artifacts are missing
                            )
                            def metadataFile = "deployment-${buildNum}.txt"
                            if (!fileExists(metadataFile)) {
                                echo "Warning: Metadata file ${metadataFile} not found for build ${buildNum}. Skipping."
                                continue
                            }
                            def metadata = readFile metadataFile
                            metadata.eachLine { line ->
                                def parts = line.split('=', 2)
                                if (parts.size() == 2) {
                                    env[parts[0]] = parts[1]
                                }
                            }
                            if (!env.NAMESPACE) {
                                echo "Warning: Namespace not found in metadata for build ${buildNum}. Skipping."
                                continue
                            }
                            echo "Deleting old deployment for namespace: ${env.NAMESPACE}, Build: ${buildNum}"
                            sh "kubectl delete namespace ${env.NAMESPACE} || true"
                        } catch (Exception e) {
                            echo "Error deleting deployment for build ${buildNum}: ${e.message}"
                            // Continue to next build instead of failing
                        }
                    }
                }
            }
        }
        stage('Stop Minikube') {
            steps {
                sh 'minikube stop || true' // Prevent failure if Minikube is already stopped
            }
        }
    }
    post {
        always {
            cleanWs()
        }
        success {
            echo "Successfully deleted deployment(s)"
        }
        failure {
            echo "Failed to delete deployment(s). Check logs for details."
        }
    }
}
